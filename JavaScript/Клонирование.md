2 типа клонирования:
1. Поверхностное (shallow copy) - Копируются **только ссылки первого уровня**. Вложенные объекты остаются **общими по ссылке**.
2. Глубокое копирование - Создаётся **полная независимая копия** всей структуры.

Поверхностное (shallow copy) клонирование: (способы)
- `Object.assign({}, obj)`
- `{ ...obj }`
- `Array.prototype.slice()`
- `[...arr]`

Глубокое копирование: (способы)

```javascript
const clone = JSON.parse(JSON.stringify(obj));
```

Минусы:
- теряет `undefined`, `Symbol`, `function`
- не работает с `Date`, `RegExp`
- падает на циклических ссылках
- ломает классы
- теряет `Map`, `Set`

```javascript
const clone = structuredClone(obj);
```

Плюсы:
- поддерживает `Map`, `Set`, `Date`, `RegExp`
- работает с циклическими ссылками
- нативный и быстрый

Минусы:
- не копирует функции
- недоступен в старых браузерах
- нельзя кастомизировать

Пример реализации DeepClone

```javascript
function deepClone(value) {
  if (value === null || typeof value !== 'object') {
    return value;
  }

  if (Array.isArray(value)) {
    return value.map(deepClone);
  }

  const result = {};
  for (const key in value) {
    result[key] = deepClone(value[key]);
  }

  return result;
}
```

Различие циклов: 
Основное отличие `for...in` от `Object.keys()` заключается в работе с цепочкой прототипов: `for...in` перебирает все перечисляемые свойства объекта, включая унаследованные из прототипов, в то время как `Object.keys()` возвращает массив только собственных (own) перечисляемых свойств.
Цикл `for...of` в JavaScript предназначен для перебора итерируемых объектов (массивы, строки, Map, Set) и получения значений элементов напрямую, а не индексов или ключей, как в старых циклах, что делает код более кратким и читаемым для коллекций.