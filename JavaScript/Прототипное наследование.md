В JavaScript объекты имеют специальное скрытое свойство `[[Prototype]]` (как указано в спецификации), которое равно либо null, либо ссылается на другой объект. Этот объект называется `прототип`

Когда необходимо прочитать свойство из объекта, а оно отсутствует, то оно берётся из прототипа. Такой механизм называется `прототипным наследованием`

Свойство `[[Prototype]]` внутреннее и скрытое, но есть несколько способов его задать:

1. Свойство `__proto__` - геттер/сеттер для `[[Prototype]]` (используется только для чтения свойств)
2. Использовать функции `Object.getPrototypeOf/Object.setPrototypeOf`

У функций (за исключением стрелочных) есть обычное свойство `F.prototype` Это ещё не «прототип объекта», а обычное свойство `F` с таким именем. По умолчанию `"prototype"` – объект с единственным свойством `constructor`, которое ссылается на функцию-конструктор. Свойство `F.prototype` (не путать с `[[Prototype]]`) устанавливает`[[Prototype]]` для новых объектов при вызове `new F()`


Краткая нотация `obj = {}` – это то же самое, что и `obj = new Object()`, где `Object` – встроенная функция-конструктор для объектов с собственным свойством `prototype`, которое ссылается на огромный объект с методом `toString` и другими.

Когда вызывается `new Object()` (или создаётся объект с помощью литерала `{...}`), свойство `[[Prototype]]` этого объекта устанавливается на `Object.prototype`

```js
let obj = {};

alert(obj.__proto__ === Object.prototype); // true
```
