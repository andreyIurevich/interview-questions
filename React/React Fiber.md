React Fiber - ключевой алгоритм библиотеки React, который решает две основные задачи:
1. **Инкрементальный процесс рендеринга** — способность разделять работу рендера на части.
2. Возможность **не блокирующего рендеринга**, при котором рендер не должен блокировать взаимодействия пользователя с сайтом и отображение анимации.

Работа по обновлению делится на два этапа:
1. Этап рендеринга (render phase)
	**Рендеринг** — это процесс, в рамках которого React опрашивает ваши компоненты, требуя от них актуальное описание той секции пользовательского интерфейса, за которую они отвечают, основываясь на текущей комбинации пропсов (`props`) и состояния (`state`).
	
	React начинает процесс рендеринга с корня дерева компонентов и циклически спускается вниз, чтобы найти все компоненты, помеченные как требующие обновления. Для каждого помеченного компонента React вызывает либо `classComponentInstance.render()` (для классовых компонентов), либо `FunctionComponent()` (для функциональных компонентов) и сохраняет результат рендеринга.
	
	Результат рендеринга компонентов обычно представлен в виде JSX-кода, который затем компилируется и развертывается как JS-код, принимая вид серии вызовов `React.createElement()`. Функция `createElement` возвращает _React-элементы_, представляющие собой простые JS-объекты, описывающие желаемую структуру пользовательского интерфейса.
	
	Cобрав результаты рендеринга всего дерева компонентов, React делает сравнение с новым деревом объектов (его часто называют «виртуальной DOM») и составляет список всех изменений, которые нужно внести в «настоящую» DOM, чтобы привести ее к желаемому в данный момент виду. Процесс сопоставления двух деревьев и вычисления разницы между ними называется **согласованием**.

	Согласование (reconcilation)
	
	Для вычисления разницы между деревьми React реализует эвристический алгоритм O(n), который основывается на двух предположениях:
	
	1. Два элемента с разными типами произведут разные деревья.
	2. Разработчик может указать, какие дочерние элементы могут оставаться стабильными между разными рендерами с помощью пропа `key`.

	**Алгоритм сравнения**
	
	При сравнении двух деревьев первым делом React сравнивает два корневых элемента. Поведение различается в зависимости от типов корневых элементов.
	1. Элементы различных типов
		Всякий раз, когда корневые элементы имеют различные типы, React уничтожает старое дерево и строит новое с нуля. Переходы от `<a>` к `<img>`, или от `<Article>` к `<Comment>`, или от `<Button>` к `<div>` приведут к полному перестроению.
		При уничтожении дерева старые DOM-узлы удаляются. Экземпляры компонента получают `componentWillUnmount()`. При построении нового дерева, новые DOM-узлы вставляются в DOM. Экземпляры компонента получают `componentWillMount()`, а затем `componentDidMount()`. Любое состояние, связанное со старым деревом, теряется.
		Любые компоненты, лежащие ниже корневого, также размонтируются, а их состояние уничтожится.
	2. Элементы одного типа
		При сравнении двух React DOM-элементов одного типа, React смотрит на атрибуты обоих, сохраняет лежащий в основе этих элементов DOM-узел и обновляет только изменённые атрибуты.
	
2. Этап фиксации (commit phase) - Используя наработки из предыдущей фазы, вызываются методы жизненного цикла и хуки, а также обновляется DOM.

Виртуальный DOM (VDOM) — это концепция программирования, в которой идеальное или «виртуальное» представление пользовательского интерфейса хранится в памяти и синхронизируется с «настоящим» DOM при помощи библиотеки, такой как ReactDOM. Этот процесс называется согласованием.

Подробнее:
1. [Согласование. Алгоритм сравнения](https://reactdev.ru/archive/react16/reconciliation/#elements-of-different-types)
2. [Описание React Fiber и Concurrency](https://habr.com/ru/articles/763534/)
3. [Описание процесса рендеринга](https://habr.com/ru/companies/otus/articles/595321/)

