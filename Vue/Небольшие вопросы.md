Отличие v-show от v-if

`v-if` выполняет «настоящую» условную отрисовку, так как гарантирует, что слушатели событий и дочерние компоненты внутри блока должным образом уничтожаются и воссоздаются при переключениях условия.

`v-if` также **ленивый**: если условие ложно на момент первоначальной отрисовки, то он ничего не сделает — условный блок не будет отрисован до тех пор, пока условие не станет истинным.

Для сравнения, `v-show` намного проще — элемент всегда отрисовывается, вне зависимости от исходного состояния с переключением на основе css-свойства display.

Вычисляемые свойства

Функция `computed()` ожидает передачи [функции-геттера](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get#description) и возвращает значение в виде **ref вычисляемого свойства**.

Вычисляемые свойства в виде ref-ссылок также автоматически разворачиваются в шаблонах, поэтому можно ссылаться на них без `.value` в выражениях шаблонов.

Вычисляемое свойство автоматически отслеживает свои реактивные зависимости

Вычисляемые свойства кэшируются на основе своих реактивных зависимостей

Лучшие практики по работе с выч. свойствами:
1. Функции-геттеры должны быть без побочных эффектов
2. Избегать мутации вычисляемого состояния. Возвращаемое значение вычисляемого свойства это производное состояние. Считайте его временным снимком — при каждом изменении состояния источника создаётся новый снимок.

Компонент

Компоненты позволяют нам разделить пользовательский интерфейс на независимые и многократно используемые части и думать о каждой части в отдельности.

Входные параметры — это настраиваемые атрибуты, которые вы можете зарегистрировать в компоненте.

Однонаправленный поток данных
Все входные параметры образуют **одностороннюю привязку** между дочерним свойством и родительским: когда родительское свойство обновляется — оно будет передаваться дочернему, но не наоборот. Это предотвращает случайное изменение дочерними компонентами родительского состояния, что может затруднить понимание потока данных приложения.

Статья о props - https://habr.com/ru/companies/simbirsoft/articles/765024/#4.2

Отличие глобальной и локальной регистрации компонентов

1. Глобальная регистрация не позволяет системам сборки удалять неиспользуемые компоненты ("tree-shaking"). Если вы глобально зарегистрировали компонент, но не используете его в своём приложении, он всё равно будет включён в финальную сборку
2. Глобальная регистрация делает зависимости менее явными в больших приложениях. Это затрудняет поиск реализации дочернего компонента через, использующий его, родительский компонент. Подобно использованию большого количества глобальных переменных, это может повлиять на долгосрочную поддержку

Локальная регистрация ограничивает доступность зарегистрированных компонентов только текущим компонентом. Это делает зависимости более явными и более дружелюбными к tree-shaking

vue-loader

Это загрузчик для [webpack](https://webpack.js.org/), который позволяет вам использовать компоненты Vue в формате, именуемым [однофайловыми компонентами](https://vue-loader.vuejs.org/ru/spec.html)

Однофайловый компонент - это файл с расширением `*.vue` Файл `*.vue` это собственный формат Vue, использующий HTML-подобный синтаксис для описания компонента. Каждый `*.vue` файл состоит из трёх главных секций: `<template>`, `<script>` и `<style>`, а также опциональных пользовательских блоков.

`vue-loader` парсит файл, извлекает каждую из секций, обрабатывает их при необходимости другими загрузчиками webpack, и в итоге собирает всё обратно в ES-модуль где экспорт по умолчанию будет объектом настроек компонента Vue.js.

`vue-loader` предоставляет возможность использовать нестандартные языки, например пре-процессоры CSS и языки шаблонов компилируемые в HTML, указывая атрибут `lang` для секции файла. Например, вы можете использовать Sass для стилей вашего компонента

Реактивность

Реактивность — это механизм, который автоматически обновляет пользовательский интерфейс в ответ на изменения состояния приложения. В основе механизма реактивности лежит система отслеживания зависимостей между компонентами приложения и их состоянием.

Composition Api предоставляет два способа объявления реактивных состояний: с помощью функций ref() и reactive() 

Функция ref() принимает аргумент и возвращает объект со свойством .value

В стандартном JavaScript нет способа обнаружить доступ к обычным переменным или их изменение. Однако мы можем перехватывать операции получения и установки свойств объекта с помощью методов getter и setter.

Свойство `.value` дает Vue возможность обнаружить, когда к ссылке обращались или она была изменена. Под капотом Vue выполняет отслеживание в геттере, а срабатывание - в сеттере. Концептуально, вы можете представить себе ref как объект, который выглядит следующим образом:

```javascript
const myRef = { 
	_value: 0, 
	get value() { 
		track() 
		return this._value 
	}, 
	set value(newValue) { 
		this._value = newValue 
		trigger() 
	}
}
```

В отличие от ref, который оборачивает внутреннее значение в специальный объект, `reactive()` делает сам объект реактивным. Реактивные объекты представляют собой [JavaScript прокси](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) и ведут себя так же, как обычные объекты. Разница в том, что Vue может перехватывать доступ и мутацию всех свойств реактивного объекта для отслеживания и запуска реактивности.

Ограничения reactive:
1. Работает только для типов объектов
2. Не дружелюбен к деструктуризации

Способы взаимодействия компонентов:
1. props/emits
2. provide/inject
3. composable (composition API) (позволяет использовать одну логику с состоянием в нескольких компонентах)
4. state manager (Vuex/Pinia)

Подробнее - https://habr.com/ru/articles/668072/

Плагины

Плагины — это самодостаточный код, который обычно добавляет функциональность к Vue на уровне приложения

Сценарии использования:
1. Регистрация одного или нескольких глобальных компонентов или пользовательских директив в [`app.component()`](https://ru.vuejs.org/api/application.html#app-component) и [`app.directive()`](https://ru.vuejs.org/api/application.html#app-directive)
2. Добавление некоторых свойств или методов глобального экземпляра, присоединив их к [`app.config.globalProperties`](https://ru.vuejs.org/api/application.html#app-config-globalproperties)

Пользовательские директивы

Пользовательские директивы в основном предназначены для повторного использования логики, связанной с низкоуровневым доступом к DOM для простых элементов.
Пользовательская директива определяется как объект, содержащий хуки жизненного цикла, аналогичные хукам компонента. Хуки получают элемент, к которому привязана директива.

Подробнее - https://ru.vuejs.org/guide/reusability/custom-directives.html

Composable

В контексте приложений Vue "composable" функция — это функция, использующая Composition API Vue для инкапсуляции и повторного использования логики с отслеживанием состояния
