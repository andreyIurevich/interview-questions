`useEffect` 

Принимает 2 аргумента, второй необязателен.

1. Второй аргумент не передан (только функция обратного вызова) - функция обратного вызова будет вызываться после каждого рендера
2. Второй аргумент - пустой массив зависимостей. Функция обратного вызова будет вызвана только после первого рендера. 
3. Второй аргумент - массив зависимостей. Функция обратного вызова будет вызвана после первого рендера, а также после обновления любого элемента из массива зависимостей. 

Функция обратного вызова может возвращать функцию отчистки (cleanup)
Функция cleanup будет вызвана при размонтировании компонента, либо до обновления любого значения из массива зависимостей.

`useLayoutEffect`

Синхронный и будет вызван **до** того, как браузер сможет отрисовать компоненты. Срабатывает когда компоненты уже находятся в virtual dom (в памяти и можно прочитать/установить различные свойств), но еще не были отрисованы браузером. Хук `useLayoutEffect` позволяет вычислять параметры компонентов и изменять их до того, как браузер отрендерит их. Это предотвращает "мерцание" компонентов и улучшает производительность, потому что рендеринг происходит только 1 раз.

`useRef`

Принимает единственный аргумент в качестве начального значения. Возвращает объект со свойством current.

При след. рендере вернёт тот же объект.
При изменении свойства current не вызывает перерендера компонента.

`useCallback`

Принимает 2 аргумента - функцию обратного вызова и массив зависимостей.

В JavaScript функции считаются объектами. Это приводит к тому, что при каждом рендере или повторном рендере компонента любая функция внутри него пересоздается как новый объект. Таким образом, даже если логика функции остается абсолютно неизменной, React будет воспринимать ее как новую сущность каждый раз.

Это может приводить к след. проблемам:

1. **Каскадные повторные рендеры**. В глубоко вложенных деревьях компонентов ненужные повторные рендеры могут каскадно распространяться вниз, вызывая значительную нагрузку на производительность.
2. **Ненужные вычисления**. Каждый повторный рендер включает процесс согласования (reconciliation) в React, который может быть вычислительно затратным, особенно для сложных компонентов React.
3. **Увеличение потребления памяти**. Постоянное создание новых экземпляров функций может привести к увеличению потребления памяти с течением времени.

Алгоритм работы `useCallback`

После добавления **useCallback()** React будет мемоизировать экземпляр переданной функции между повторными рендерами. Вот что происходит:

1. **При начальном рендере** React создает функцию и возвращает ее.

2. **При последующих рендерах** React будет:

	 проверять, изменились ли значения в массиве зависимостей;
    
	 если ничего не изменилось, он возвращает тот же экземпляр функции, что и при предыдущем рендере;
    
	 если что-то изменилось, React создает новый экземпляр функции и возвращает его.

Это означает, что пока зависимости не изменяются, на каждом рендере будет возвращаться один и тот же экземпляр функции.

Случаи использования `useCallback`:

1. **Оптимизация производительности в списках**. Когда рендерится список элементов, возможно, вам нужно передать функцию обратного вызова каждому элементу. Использование **useCallback()** гарантирует, что каждый элемент получит одну и ту же функцию, предотвращая ненужные повторные рендеры.
2. **Когда функция обратного вызова является зависимостью в useEffect().** Используйте **useCallback()**, когда функция обратного вызова является зависимостью в хуке **useEffect()**, чтобы избежать ненужного выполнения эффекта.
3.  **При работе с кастомными хуками.** Используйте **useCallback()**, чтобы гарантировать консистентность ссылок на функции при создании кастомных хуков, которые возвращают функции обратного вызова, особенно если эти функции будут использоваться в качестве зависимостей в эффектах.
4.  **Передача функций обратного вызова в дочерние компоненты**. Если ссылки на функцию изменяются, дочерние компоненты могут перерендериваться без необходимости. **useCallback()** помогает предотвратить это, мемоизируя функцию и гарантируя, что она изменится только тогда, когда изменятся ее зависимости.

`useMemo` - мемоизирует вычисленное значение

Рекомендуется использовать `useCallback` и `useMemo` в связке с функцией `memo`

